[{"content":"","date":"7 January 2024","permalink":"/","section":"","summary":"","title":""},{"content":"","date":"7 January 2024","permalink":"/tags/backend/","section":"Tags","summary":"","title":"backend"},{"content":"","date":"7 January 2024","permalink":"/tags/cgi/","section":"Tags","summary":"","title":"cgi"},{"content":"","date":"7 January 2024","permalink":"/tags/http/","section":"Tags","summary":"","title":"http"},{"content":"After finishing the Rust book and its final project (a very simple HTTP server), I decided to expand it to deal with more scenarios, and also add in some dynamic behavior with CGI for fun. This was a good opportunity to learn more about HTTP and CGI and inspired me to write about it.\nAn introduction to the HTTP protocol # The HTTP protocol is used to access resources and transmit data over the web. When you access a web page in a browser, it sends an HTTP request to a computer running the server. Consider the following request:\nGET / HTTP/1.1 Host: example.org The first line contains an HTTP verb, in this case GET. There are different HTTP verbs (or methods) used to perform different actions with a given resource. The GET method conventionally indicates that we want to read the resource. The following \\ represents a path to the resource we want to access (in this case, the root path). And finally, HTTP/1.1 represents which version of HTTP we are using. Following this first line, a list of headers is supplied. These headers give the server some metadata about our request. In our case, we just supplied the Host header, which tells the server program what is the domain to which we are sending our request.\nIf you have the netcat command available, you can actually interact with an HTTP server and directly send a request. Run netcat example.org 80, which opens up a TCP connection to example.org at port 80 (the default port for HTTP). Then you can copy and paste the request above and press enter twice. The server will respond with something like this:\nHTTP/1.1 200 OK Accept-Ranges: bytes *a bunch of other HTTP headers* ... Content-Length: 1256 *the actual HTML for the page* At this point you can close the connection to the server by killing netcat with CTRL+C.\nThe response contains an initial line that is somewhat similar to the request\u0026rsquo;s, indicating the HTTP version being used, and then an HTTP status code, in this case 200 OK indicating that the request could be fulfilled successfully. Following that we have some headers for the response, a blank line, and then the actual data of interest (the body).\nSpeaking of it, the HTTP request can also have a body, for instance:\nPOST /anything HTTP/1.1 Host: httpbin.org Content-Length: 10 1234567890 The above request accesses the /anything path on httpbin.org, a utility for inspecting and testing HTTP requests. This specific path responds with data about the request sent to it. If you run netcat httpbin.org 80 and send this request you will get a response similar to this:\nHTTP/1.1 200 OK Date: Thu, 28 Dec 2023 05:28:02 GMT Content-Type: application/json Content-Length: 332 Connection: keep-alive Server: gunicorn/19.9.0 Access-Control-Allow-Origin: * Access-Control-Allow-Credentials: true { \u0026#34;args\u0026#34;: {}, \u0026#34;data\u0026#34;: \u0026#34;1234567890\u0026#34;, \u0026#34;files\u0026#34;: {}, \u0026#34;form\u0026#34;: {}, \u0026#34;headers\u0026#34;: { \u0026#34;Content-Length\u0026#34;: \u0026#34;10\u0026#34;, \u0026#34;Host\u0026#34;: \u0026#34;httpbin.org\u0026#34;, \u0026#34;X-Amzn-Trace-Id\u0026#34;: \u0026#34;...\u0026#34; }, \u0026#34;json\u0026#34;: 1234567890, \u0026#34;method\u0026#34;: \u0026#34;POST\u0026#34;, \u0026#34;origin\u0026#34;: \u0026#34;XXX.XXX.XXX.XXX\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://httpbin.org/anything\u0026#34; } Here we get a JSON formatted response containing the request body, as seen in the data section of the response. The headers section displays the request headers we sent (the X-Amzn-Trace-Id header wasn\u0026rsquo;t sent by us, but was added on their end). The request body is used for sending additional information to the server such as form data.\nsequenceDiagram participant B as Browser participant S as HTTP Server participant F as Filesystem B-\u003e\u003eS: GET / HTTP/1.1\nHost: example.org S-\u003e\u003eF: Read contents of index.html F-\u003e\u003eS: Page contents S-\u003e\u003eB: HTTP/1.1 200 OK\nDate: Thu, 28 Dec 2023 05:28:02 GMT\nContent-Type: application/json\nContent-Length: 332\nFile contents... Request/response cycle for a static HTTP server An HTTP server\u0026rsquo;s job is to receive and parse requests and return the correct HTTP responses. A simple server is able to serve static HTML pages and files, but many modern applications require things such as database access, file storage, connection to external services, etc. To deal with these scenarios we need servers capable of running more intricate code for each request and generating the content to be returned to the user.\nDynamic behaviour with CGI # One way to add the dynamic behaviors described above is through CGI (or Common Gateway Interface). It is an interface definition for HTTP servers and it specifies how to communicate with external programs when a request is received. Then, as long as this external program conforms to the CGI specification, it can read the incoming data and generate an adequate response.\nFrom now on we will refer to an external program which can communicate to a server via CGI as a CGI script (although compiled programs also work perfectly fine for this). HTTP servers capable of communicating with such programs will be referred to as CGI servers.\nsequenceDiagram participant B as Browser participant S as CGI Server participant Sc as CGI Script B-\u003e\u003eS: GET /cgi-bin/example.pl HTTP/1.1\nHost: myexamplecgiserver.org S-\u003e\u003eSc: Request data via environment\nvariables and standard input activate Sc Note right of Sc: Here the script can\naccess databases,\nread files,\nrun computations,\netc... Sc-\u003e\u003eS: Execution response deactivate Sc S-\u003e\u003eB: HTTP/1.1 200 OK\nDate: Thu, 28 Dec 2023 05:28:02 GMT\nContent-Type: application/json\nContent-Length: 332\nFile contents... Request/response cycle for a CGI server Interface description # When a CGI server receives an incoming request, it needs to check if it should return a static page or call a CGI script, which is usually inferred by the request path. CGI scripts are commonly accessed via paths beginning with /cgi-bin/. It then executes the corresponding script from the configured folder in a new process. General data about the request is sent via CGI Metavariables, which are similar in spirit to HTTP headers and passed as environment variables to the process, and the request body is sent via standard input. After the script is finished executing, it returns the response metadata as well as the body formatted such that it can be parsed by the server and returned as a proper HTTP response.\nPrecise details regarding the metadata sent to CGI scripts and back to the server can be found in the official RFC (3875), but an overview of such details is given below.\nCGI Metavariables # Metavariable Description AUTH_TYPE Identifies the authentication mechanism being used by the server to authenticate the user, if any. CONTENT_LENGTH Size of the body of the incoming request. Must be set if there is any body content in the request. CONTENT_TYPE The MIME type of the body of the incoming request, if present. GATEWAY_INTERFACE Specifies the dialect of CGI being used by the server (CGI/1.1 , for example). PATH_INFO A URI path to be interpreted by the CGI script. PATH_TRANSLATED A translated version of the above path after being parsed as a local URI and translated to the server\u0026rsquo;s document repository structure (to be completely fair, I have no idea why this would be useful, but since the CGI interface is quite dated, maybe it made sense in its original context). QUERY_STRING The query string supplied in the incoming request. It\u0026rsquo;s normally what comes after ? in the URI. REMOTE_ADDR The network address of the client sending the request (an IPv4 or IPv6 value). REMOTE_HOST The fully qualified domain name of the client sending the request. As long as I am aware, this field only makes sense if the client is registered in a DNS server. REMOTE_IDENT Provides identity information reported about the connection. REMOTE_USER User identification string supplied by the client as part of user authentication, if applicable. Must be set depending on the value of the AUTH_TYPE metavariable. REQUEST_METHOD The HTTP method used by the script to process the request, e.g., GET, POST, PUT, DELETE. SCRIPT_NAME The section of the URI path which specifies which CGI script is being called (for instance, if the path was /cgi-bin/my_script.py, this would be set to my_script.py). SERVER_NAME Name of the server host to which the client request is directed. It usually means the name of the machine running the CGI server. SERVER_PORT The TCP/IP port on which this request was received. SERVER_PROTOCOL The name and version of the application protocol used for this CGI request. SERVER_SOFTWARE The name and version of the CGI Server. In my project I used the name \u0026ldquo;Rust Web CGI/0.0.1\u0026rdquo;. HTTP headers not covered by the fields above can be passed to the CGI script via extra metavariables prefixed with HTTP_.\nCGI Response # The output from the CGI script is returned via the standard output. It contains a header section and a body section, separated by a blank line. The header section contains one CGI header per line (not to be confused with HTTP headers) and the body is returned to the client as is. The CGI response headers define what kind of response is to be generated.\nCGI response header fields # Response header field Description Content-Type The MIME type of the body of the CGI response, if present. Location Specifies to the server that the script is returning a reference to a document. Then, this field will contain either an absolute URI or a local URI path. Status The HTTP status to be returned. As with the CGI metavariables, the script is allowed to return extra headers relating to the HTTP protocol or to the specific CGI implementation.\nCGI response types # Response type Description Document response When the response contains a Content-Type header and a response body. It is the most straightforward response, and the body is returned to the user with the required HTTP metadata. Local redirect response When the response contains a Location header and its value represents a local URI path. In this case the server generates the response that it would have produced if a request to the specified local URI path was received. For example, if the server is receiving a request for http://example.com and a Location header of example.html was returned by the script, the server will return the same as if the client\u0026rsquo;s request was directed towards http://example.com/example.html. Client redirect response When the response contains a Location header and its value represents an absolute URI path. In this case the server responds with a 302 Found status and a reference to the URI for which the client is being redirected. Client redirect response with document This case is similar to the previous one, except that a message body is also returned by the CGI script, as well as a Content-Type and Status. The client is redirected but the message body is returned to the client as well. If the client is a web browser, this response body is most likely going to be ignored. Some CGI script examples # To understand the CGI interface more concretely, let\u0026rsquo;s discuss some examples. The examples below can be found in the repository for my CGI server implementation in Rust:\n1 2 3 4 5 6 7 #!/bin/bash read INDATA printf \u0026#34;Content-Type: text/html\\n\\n\u0026#34; printf \u0026#34;Body: ${INDATA}\u0026lt;br /\u0026gt;\u0026#34; export VAR=$(env) printf \u0026#34;${VAR//$\u0026#39;\\n\u0026#39;/\u0026lt;br /\u0026gt;}\u0026#34; The example above is a bash script that returns an HTML page containing the environment variables it received as well as the incoming request body.\nDo not use such a script in production! The generated response exposes all environment variables sent to the script, and might contain sensitive data! In this case, we are accessing the environment variables and standard input directly, but some languages have tools to abstract this interfacing for us. Take for instance our next example, now in Python:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #!/bin/python # Import modules for CGI handling import cgi # Create instance of FieldStorage form = cgi.FieldStorage() # Get data from fields first_name = form.getvalue(\u0026#39;first_name\u0026#39;) last_name = form.getvalue(\u0026#39;last_name\u0026#39;) print(\u0026#34;Content-type:text/html\u0026#34;) print() print(\u0026#34;\u0026lt;html\u0026gt;\u0026#34;) print(\u0026#39;\u0026lt;head\u0026gt;\u0026#39;) print(\u0026#34;\u0026lt;title\u0026gt;Greeter\u0026lt;/title\u0026gt;\u0026#34;) print(\u0026#39;\u0026lt;/head\u0026gt;\u0026#39;) print(\u0026#39;\u0026lt;body\u0026gt;\u0026#39;) print(\u0026#34;\u0026lt;h2\u0026gt;Hello %s %s\u0026lt;/h2\u0026gt;\u0026#34; % (first_name, last_name)) print(\u0026#39;\u0026lt;/body\u0026gt;\u0026#39;) print(\u0026#39;\u0026lt;/html\u0026gt;\u0026#39;) In this example, we use the cgi module which parses data sent via a request so that we can acess it directly. This page might be accessed after submitting the following form:\n1 2 3 4 5 6 \u0026lt;form action = \u0026#34;/cgi-bin/simple_form.py\u0026#34; method = \u0026#34;post\u0026#34;\u0026gt; First Name: \u0026lt;input type = \u0026#34;text\u0026#34; name = \u0026#34;first_name\u0026#34;\u0026gt;\u0026lt;br /\u0026gt; Last Name: \u0026lt;input type = \u0026#34;text\u0026#34; name = \u0026#34;last_name\u0026#34; /\u0026gt; \u0026lt;input type = \u0026#34;submit\u0026#34; value = \u0026#34;Submit\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; As long as the Python script resides in the /cgi-bin/simple_form.py path, after submitting this form we will be greeted with the supplied first and last names correctly set.\nCGI drawbacks and modern alternatives # Nowadays CGI isn\u0026rsquo;t used as much, and more modern mechanisms have been developed. One of the main drawbacks of CGI is that it creates a separate process every time it receives a request for a CGI script, which creates a lot of overhead and makes the server less performant. We have new alternatives: the Apache HTTP server, for instance, has modules supporting communication with specific languages (mod_perl, mod_php, mod_python, etc). There are also language-specific mechanisms such as Python\u0026rsquo;s WSGI and specific programs for receiving these requests, such as Gunicorn. These can be called by more general HTTP servers acting as a reverse proxy, such as the Apache server or Nginx.\nConclusion # The CGI specification was written in 1993 as a way to allow developers to create scripts that integrated with HTTP servers for dynamic interactions. Even though it isn\u0026rsquo;t as popular anymore, understanding the inner workings, advantages and drawbacks of old interfaces and protocols can give us an understanding of why modern solutions are implemented as they are. It can also give us an appreciation for the engineering work that goes into defining and perfecting these interfaces and protocols that will be used by people all over the world. Implementing a simple version of this certainly was a fun experience, and if you are curious to see such an implementation you are welcome to see my repository and play with it! :)\nlucasaug/rust-web-cgi An HTTP server written in Rust with basic CGI support Rust 0 0 Thank you so much for reading my first post!\nReferences # RFC 3875 (the original proposal for the CGI interface) Chapter 3 of \u0026ldquo;CGI Programming 101\u0026rdquo;, by Jacqueline D. Hamilton Chapter 3.2 of O\u0026rsquo;Reilly\u0026rsquo;s \u0026ldquo;CGI Programming on the World Wide Web\u0026rdquo;, by Shishir Gundavaram Credits # Thumbnail image by Miguel Á. Padriñán on Pexels ","date":"7 January 2024","permalink":"/posts/writing-a-cgi-server-in-rust/","section":"Posts","summary":"An overview of HTTP servers and CGI","title":"HTTP servers and an overview of the CGI interface"},{"content":"","date":"7 January 2024","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"7 January 2024","permalink":"/tags/project/","section":"Tags","summary":"","title":"project"},{"content":"","date":"7 January 2024","permalink":"/tags/rust/","section":"Tags","summary":"","title":"rust"},{"content":"","date":"7 January 2024","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"7 January 2024","permalink":"/tags/web/","section":"Tags","summary":"","title":"web"},{"content":" Projects # ","date":"6 December 2023","permalink":"/projects/","section":"","summary":" Projects # ","title":""},{"content":"","date":"6 December 2023","permalink":"/projects/rust-web-cgi/","section":"","summary":"A simple implementation of a CGI-capable HTTP server in Rust","title":"Rust Web CGI"},{"content":" Hello, my name is Lucas! I'm a brazilian software developer with a B.S. degree in Computer Science from the Federal University of Minas Gerais. I have been working with software development since 2014, mostly with back-end web development, but I am always looking to expand the horizons of my knowledge.\n","date":"27 November 2023","permalink":"/about/","section":"","summary":"Hello, my name is Lucas!","title":""},{"content":"","date":"4 October 2020","permalink":"/projects/http-runner/","section":"","summary":"My entry to the 2020 edition of JS13K.","title":"HTTP Runner"}]